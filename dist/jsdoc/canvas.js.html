<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: canvas.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: canvas.js</h1>

    


    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>var _ = require("lodash");
var binder = require("./events").binder;
var DecksEvent = require("./events").DecksEvent;
var hasEmitter = require("./events").hasEmitter;
var rect = require("./utils").rect;
var dom = require("./ui").dom;
var GestureHandler = require("./ui").GestureHandler;
var Layout = require("./layout");

/**
 * Canvas - manages the main DOM element in which items are rendered, and where
 * UI/touch/gesture events are first handled.
 *
 * @class
 * @mixes binder
 * @param {Object} options additional options
 */
function Canvas(options) {
  if (!(this instanceof Canvas)) {
    return new Canvas(options);
  }

  options = _.merge({}, this.defaultOptions, options);

  this.setAnimator(options.animator);
  this.setConfig(options.config);
  this.setEmitter(options.emitter, this.emitterEvents);
  this.setLayout(options.layout);
  this.setElement(options.element || dom.create("div"));

  this.bindEvents(window, this.windowEvents);
}

_.extend(Canvas.prototype, binder, hasEmitter, /** @lends Canvas.prototype */ {
  defaultOptions: {
    //minItemPadding: { top: 0, bottom: 10, left: 0, right: 0 }
  },

  emitterEvents: {
    "deck:layout:set": "onDeckLayoutSet",
    "frame:bounds:set": "onFrameBoundsSet",
    "viewport:render:drawing": "onViewportRenderDrawing",
    "viewport:render:removed": "onViewportRenderRemoved",
    "viewport:all:renders:drawn": "onViewportAllRendersDrawn",
    "gesture:element:moved": "onGestureElementMoved"
  },

  windowEvents: {
    "resize": "onWindowResize", // TODO: might want to debounce this
    "scroll": "onWindowScroll" // TODO: might want to debounce this
  },

  defaultGestureHandlerOptions: {
    gestures: {
      mouseWheel: {
        enabled: true,
        horizontal: true,
        vertical: true
      },
      pan: {
        enabled: true,
        horizontal: true,
        vertical: true
      },
      swipe: {
        enabled: true,
        horizontal: true,
        vertical: true
      },
      tap: {
        enabled: true
      },
      press: {
        enabled: true
      }
    }
  },

  setAnimator: function(animator) {
    if (!animator) {
      throw new Error("Canvas#setAnimator: animator is required");
    }

    if (this.animator) {
      throw new Error("Canvas#setAnimator: animator already set");
    }

    this.animator = animator;
  },

  setConfig: function(config) {
    if (!config) {
      throw new Error("Canvas#setConfig: config is required");
    }

    if (this.config) {
      throw new Error("Canvas#setConfig: config already set");
    }

    this.config = config;
  },

  /**
   * Sets the main container element, where items are rendered.  Creates a
   * div if no element is provided
   *
   * @param {?HTMLElement} element element for the container
   * @param {?Object} options additional options
   * @return {undefined}
   */
  setElement: function(element) {
    if (!_.isElement(element)) {
      throw new Error("Canvas#setElement: element is required and must be an Element");
    }

    if (this.element) {
      throw new Error("Canvas#setElement: element already set");
    }

    dom.addClass(element, this.config.canvasClassName);
    dom.setStyle(element, "position", "absolute");
    dom.setStyle(element, "top", 0);
    dom.setStyle(element, "left", 0);
    this.element = element;

    this.emit(DecksEvent("canvas:element:set", this, this.element));
  },

  setLayout: function(layout) {
    if (!(layout instanceof Layout)) {
      throw new Error("Canvas#setLayout: layout is required and must be a Layout");
    }

    /*
    if (this.layout) {
      // TODO: any tear down things here?
      //console.log("canvas: changing layouts", this.layout, layout);
    }
    */

    this.layout = layout;

    this.configureGestures();

    this.resetPosition();
  },

  setBounds: function(bounds) {
    bounds = bounds || rect.normalize(this.element);

    if (rect.isEqual(this.bounds, bounds)) { return; }

    this.bounds = bounds;
    dom.setStyle(this.element, "width", this.bounds.width);
    dom.setStyle(this.element, "height", this.bounds.height);

    this.emit(DecksEvent("canvas:bounds:set", this, this.bounds));
  },

  setFrameBounds: function(frameBounds) {
    if (!frameBounds) {
      throw new Error("Canvas#setFrameBounds: frameBounds is required");
    }

    if (rect.isEqual(this.frameBounds, frameBounds)) { return; }

    this.frameBounds = frameBounds;

    this.emit(DecksEvent("canvas:frame:bounds:set", this, this.frameBounds));

    if (!this.bounds) {
      this.setBounds(this.frameBounds);
    }

    this.configureGestures();
  },

  /**
   * Adds a render (element) to the canvas, if not already added
   *
   * @param {Object} render render to remove
   * @return {undefined}
   */
  addRender: function(render) {
    if (!render) {
      throw new Error("Canvas#addRender: render is required");
    }

    if (render.isInCanvas) {
      return;
    }

    if (!_.isElement(render.element)) {
      throw new Error("Canvas#addRender: render.element is required and must be an Element");
    }

    dom.append(this.element, render.element);
    render.isInCanvas = true;

    this.emit(DecksEvent("canvas:render:added", this, render));
  },

  /**
   * Removes a render (element) from the Canvas, if present.
   *
   * @param {Object} render render to remove
   * @return {undefined}
   */
  removeRender: function(render) {
    if (!render) {
      throw new Error("Canvas#removeRender: render is required");
    }

    if (!render.isInCanvas) {
      return;
    }

    if (!_.isElement(render.element)) {
      throw new Error("Canvas#removeRender: render.element is required and must be an Element");
    }

    dom.remove(this.element, render.element);
    render.isInCanvas = false;

    this.emit(DecksEvent("canvas:render:removed", this, render));
  },

  resizeToFitElement: function(element) {
    if (!_.isElement(element)) {
      throw new Error("Canvas#resizeToFitElement: element is required and must be an Element");
    }

    // TODO: maybe don't need to check this.frameBounds
    var bounds = rect.unionAll([element, this.bounds, this.frameBounds]);

    this.setBounds(bounds);
  },

  resizeToFitAllElements: function() {
    var itemSelector = "." + this.config.itemClassName;

    // Convert DOM list data type to a plain Array
    var elements = _.map(this.element.querySelectorAll(itemSelector), _.identity);

    if (_.isEmpty(elements)) {
      return;
    }

    // TODO: optimize w/ concat
    var allElementsBounds = rect.unionAll(elements);
    var bounds = rect.union(allElementsBounds, this.frameBounds);

    this.setBounds(bounds);
  },

  resetPosition: function() {
    this.emit(DecksEvent("canvas:position:resetting", this));

    this.animator.animate(this.element, {
      top: 0,
      left: 0
    }, {
      duration: 400,
      complete: _.bind(function() {
        this.emit(DecksEvent("canvas:position:reset", this));
      }, this)
    });
  },

  /*
  panToElement: function(element) {
    // ask layout where to put element (e.g. centered, top-left, etc)
  },
  */

  configureGestures: function() {
    if (!this.element) {
      if (this.config.debugGestures) {
        console.warn("Canvas#configureGestures: not configuring gestures - Canvas element not set yet");
      }
      return;
    }

    var canvasGestureHandlerOptions = {
      animator: this.animator,
      config: this.config,
      emitter: this.emitter,
      bounds: this.frameBounds
    };

    var layoutGestureHandlerOptions = this.layout.getCanvasGestureOptions();

    var gestureHandlerOptions = _.merge(
      {},
      this.defaultGestureHandlerOptions,
      canvasGestureHandlerOptions,
      layoutGestureHandlerOptions);

    // TODO: don't destory gestures on frame bounds change
    if (this.gestureHandler) {
      this.gestureHandler.destroy();
    }

    this.gestureHandler = new GestureHandler(this.element, gestureHandlerOptions);
  },

  onDeckLayoutSet: function(e) {
    var layout = e.data;
    this.setLayout(layout);
  },

  onFrameBoundsSet: function(e) {
    var bounds = e.data;
    this.setFrameBounds(bounds);
  },

  onViewportRenderDrawing: function(e) {
    var render = e.data;
    this.addRender(render);
  },

  onViewportAllRendersDrawn: function() {
    if (this.config.debugDrawing) {
      console.log("Canvas#onViewportAllRendersDrawn: resizing canvas to fit all elements");
    }
    this.resizeToFitAllElements();
  },

  onViewportRenderRemoved: function(e) {
    var render = e.data;
    if (this.config.debugDrawing) {
      console.log("Canvas#onViewportRenderRemoved: render removed");
    }
    this.removeRender(render);
  },

  onGestureElementMoved: function(e) {
    var element = e.data;
    if (element !== this.element) {
      return;
    }
    this.setBounds();
  },

  onWindowScroll: function() {
    this.setBounds();
  },

  onWindowResize: function() {
    this.setBounds();
  }
});

module.exports = Canvas;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Modules</h3><ul><li><a href="module-decks.html">decks</a></li><li><a href="events.html">decks/events</a></li><li><a href="layouts.html">decks/layouts</a></li><li><a href="ui.html">decks/ui</a></li><li><a href="dom.html">decks/ui/dom</a></li><li><a href="utils.html">decks/utils</a></li><li><a href="rect.html">decks/utils/rect</a></li></ul><h3>Classes</h3><ul><li><a href="BasicGridLayout.html">BasicGridLayout</a></li><li><a href="BasicStackLayout.html">BasicStackLayout</a></li><li><a href="Canvas.html">Canvas</a></li><li><a href="Deck.html">Deck</a></li><li><a href="DecksEvent.html">DecksEvent</a></li><li><a href="Emitter.html">Emitter</a></li><li><a href="Frame.html">Frame</a></li><li><a href="GestureEmitter.html">GestureEmitter</a></li><li><a href="GestureHandler.html">GestureHandler</a></li><li><a href="Item.html">Item</a></li><li><a href="ItemCollection.html">ItemCollection</a></li><li><a href="Layout.html">Layout</a></li><li><a href="MouseWheelEmitter.html">MouseWheelEmitter</a></li><li><a href="PanEmitter.html">PanEmitter</a></li><li><a href="PressEmitter.html">PressEmitter</a></li><li><a href="SwipeEmitter.html">SwipeEmitter</a></li><li><a href="TapEmitter.html">TapEmitter</a></li><li><a href="Viewport.html">Viewport</a></li><li><a href="ZoomLayout.html">ZoomLayout</a></li></ul><h3>Events</h3><ul><li><a href="PanEmitter.html#event:gesture:pan:any">gesture:pan:any</a></li><li><a href="PanEmitter.html#event:gesture:pan:cancel">gesture:pan:cancel</a></li><li><a href="PanEmitter.html#event:gesture:pan:end">gesture:pan:end</a></li><li><a href="PanEmitter.html#event:gesture:pan:start">gesture:pan:start</a></li><li><a href="PanEmitter.html#event:gesture:pan:x">gesture:pan:x</a></li><li><a href="PanEmitter.html#event:gesture:pan:y">gesture:pan:y</a></li><li><a href="PressEmitter.html#event:gesture:press">gesture:press</a></li><li><a href="SwipeEmitter.html#event:gesture:swipe:any">gesture:swipe:any</a></li><li><a href="SwipeEmitter.html#event:gesture:swipe:x">gesture:swipe:x</a></li><li><a href="SwipeEmitter.html#event:gesture:swipe:y">gesture:swipe:y</a></li><li><a href="TapEmitter.html#event:gesture:tap">gesture:tap</a></li></ul><h3>Mixins</h3><ul><li><a href="binder.html">binder</a></li><li><a href="hasEmitter.html">hasEmitter</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha5</a> on Thu Nov 06 2014 21:11:39 GMT-0700 (MST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>

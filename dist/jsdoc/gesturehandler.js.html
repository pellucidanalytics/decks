<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: ui/gesturehandler.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: ui/gesturehandler.js</h1>

    


    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>var _ = require("lodash");
var Hammer = require("hammerjs");
var binder = require("../events").binder;
var hasEmitter = require("../events").hasEmitter;
var dom = require("../ui/dom");
var rect = require("../utils").rect;
var DecksEvent = require("../events").DecksEvent;
var PanEmitter = require("./panemitter");
var SwipeEmitter = require("./swipeemitter");
var MouseWheelEmitter = require("./mousewheelemitter");
var MouseOverOutEmitter = require("./mouseoveroutemitter");
var MouseEnterLeaveEmitter = require("./mouseoveroutemitter");
var TapEmitter = require("./tapemitter");
var PressEmitter = require("./pressemitter");
var validate = require("../utils/validate");

/**
 * Object to bind and handle gesture events for a single DOM element.
 *
 * @class
 * @mixes binder
 * @mixes hasEmitter
 * @param {!Element} element - the element for which to bind and handle input gestures
 * @param {?Object} options - additional options
 */
function GestureHandler(element, options) {
  if (!(this instanceof GestureHandler)) {
    return new GestureHandler(element, options);
  }

  options = _.merge({}, this.defaultOptions, options);

  this.gestureEmitters = {};

  this.setAnimator(options.animator);
  this.setConfig(options.config);
  this.setEmitter(options.emitter || {}, this.emitterEvents);
  this.setElement(element);
  this.setOptions(options);
}

_.extend(GestureHandler.prototype, binder, hasEmitter, /** @lends GestureHandler.prototype */ {
  /**
   * Default options to use with a GestureHandler instance.
   */
  defaultOptions: {
    gestures: {
      mouseWheel: {
        enabled: true,
        horizontal: true,
        vertical: true
      },
      mouseOverOut: {
        enabled: true,
        over: true,
        out: true
      },
      mouseEnterLeave: {
        enabled: true,
        enter: true,
        leave: true
      },
      pan: {
        enabled: true,
        horizontal: true,
        vertical: true
      },
      swipe: {
        enabled: true,
        horizontal: true,
        vertical: true
      },
      tap: {
        enabled: true
      },
      press: {
        enabled: true
      }
    },
    bounds: null,
    movement: {
      /**
       * If false, gestures will cause movements on the element by changing/animating the element's top and left style.
       * If true, gestures will cause movements on the element by animating element's scroll position.
       */
      scroll: false,

      /**
       * If scroll: true, the container element must be specified.
       */
      scrollContainerElement: null,

      /**
       * Default animation options for moveemnts
       */
      animateOptions: {
        duration: 500,
        easing: "easeInOutCubic",
        queue: false
      }
    },
    snapping: {
      distanceThreshold: 40, // The pixel distance when pulling away from an edge, where movement resistance begins to be applied
      distanceScale: 0.5, // The scale factor for reducing movement when pulling away from an edge
      animateOptions: {
        duration: 200,
        easing: [500, 20] // tension (default 500), friction (default 20)
      }
    },
    inertia: {
      distanceScale: 500, // 400 used to calculate the movement distance for an inertia-based movement (swipe gesture)
      durationScale: 500, // 60 used to calculate the movement duration for an inertia-based movement (swipe gesture)
      animateOptions: {
        easing: "easeOutCubic"
      }
    }
  },

  emitterEvents: {
    "gesture:pan:start": "onGesturePanStart",
    "gesture:pan:any": "onGesturePanAny",
    "gesture:pan:x": "onGesturePanX",
    "gesture:pan:y": "onGesturePanY",
    "gesture:pan:end": "onGesturePanEnd",
    "gesture:pan:cancel": "onGesturePanCancel",

    "gesture:swipe:any": "onGestureSwipeAny",
    "gesture:swipe:x": "onGestureSwipeX",
    "gesture:swipe:y": "onGestureSwipeY",

    "gesture:tap": "onGestureTap",
    "gesture:press": "onGesturePress"
  },

  /**
   * Mapping of gesture names to gesture emitter component constructor functions
   */
  gestureEmitterTypes: {
    pan: PanEmitter,
    swipe: SwipeEmitter,
    mouseWheel: MouseWheelEmitter,
    mouseOverOut: MouseOverOutEmitter,
    mouseEnterLeave: MouseEnterLeaveEmitter,
    tap: TapEmitter,
    press: PressEmitter
  },

  setAnimator: function(animator) {
    validate(animator, "animator", { isPlainObject: true, isNotSet: this.animator });
    this.animator = animator;
  },

  setConfig: function(config) {
    validate(config, "config", { isPlainObject: true, isNotSet: this.config });
    this.config = config;
  },

  setElement: function(element) {
    validate(element, "element", { isElement: true, isNotSet: this.element });
    this.element = element;
    this.hammer = new Hammer(this.element);
  },

  setOptions: function(options) {
    validate(options, "options", { isRequired: true });

    this.movement = options.movement;

    if (this.movement.scroll &amp;&amp; !_.isElement(this.movement.scrollContainerElement)) {
      throw new Error("GestureHandler#setOptions: for scroll movement, scrollContainerElement is required");
    }

    this.setBounds(options.bounds || null);
    this.snapping = options.snapping;
    this.inertia = options.inertia;

    _.each(options.gestures, function(gestureEmitterOptions, key) {
      if (!gestureEmitterOptions.enabled) {
        return;
      }

      var GestureEmitter = this.gestureEmitterTypes[key];

      if (!GestureEmitter) {
        throw new Error("GestureHandler#setOptions: no gesture emitter component configured to handle gesture type: " + key);
      }

      _.extend(gestureEmitterOptions, {
        hammer: this.hammer,
        emitter: this.emitter
      });

      this.gestureEmitters[key] = new GestureEmitter(this.element, gestureEmitterOptions);
    }, this);
  },

  setBounds: function(bounds) {
    validate(bounds, "bounds", { isRequired: true });
    if (rect.isEqual(this.bounds, bounds)) {
      return;
    }
    this.bounds = bounds;
  },

  destroy: function() {
    _.each(this.gestureEmitters, function(gestureEmitter, key) {
      if (this.config.debugGestures) {
        console.log("GestureHandler#destroy: destroying gesture emitter: " + key);
      }

      gestureEmitter.destroy();

      delete this.gestureEmitters[key];
    }, this);

    if (this.config.debugGestures) {
      console.log("GestureHandler#destroy: destroying hammer: ", this.hammer);
    }

    this.hammer.destroy();
    delete this.hammer;

    this.unbindEvents(this.emitter, this.emitterEvents);
  },

  updatePositionData: function(e) {
    this.currentPosition = {
      event: e
    };

    // If moving by scroll, record the starting scroll top and left, otherwise, record the style top and left
    if (this.movement.scroll) {
      _.extend(this.currentPosition, {
        scrollTop: this.movement.scrollContainerElement.scrollTop,
        scrollLeft: this.movement.scrollContainerElement.scrollLeft
      });
    } else {
      _.extend(this.currentPosition, rect.normalize(this.element));
    }

    if (!this.startPosition) {
      this.startPosition = this.currentPosition;
    }
  },

  clearPositionData: function() {
    this.startPosition = null;
    this.currentPosition = null;
  },

  resetPosition: function() {
    var animateOptions = {};
    var beginOptions = {};
    var completeOptions = { waitForXAndY: true };
    this.animateMoveXAndY(0, 0, animateOptions, beginOptions, completeOptions);
  },

  animateMoveToElement: function(element, xOffset, yOffset) {
    validate(element, "GestureHandler#animateMoveToElement: element", { isElement: true });
    xOffset = xOffset || 0;
    yOffset = yOffset || 0;

    var left = dom.getStyle(element, "left", { parseFloat: true });
    var top = dom.getStyle(element, "top", { parseFloat: true });

    //console.log("left %f, top: %f, xOffset: %f, yOffset: %f", left, top, xOffset, yOffset);

    var x = left + xOffset;
    var y = top + yOffset;

    var animateOptions = {};
    var beginOptions = {};
    var completeOptions = { waitForXAndY: true };

    this.animateMoveXAndY(x, y, animateOptions, beginOptions, completeOptions);
  },

  stopAnimation: function() {
    this.animator.animate(this.element, "stop", true);
    this.clearPositionData();
    this.isAnimating = false;
  },

  /**
   * Moves the element using the information in the given Hammer event object.
   *
   * @param e - hammer pan event object (from a panmove|panleft|panright|etc.)
   * @param elementRect - the bounding client rect of the element
   * @return {undefined}
   */
  animateMoveForPan: function(e, animateOptions, beginOptions, completeOptions) {
    completeOptions.waitForXAndY = true;
    this.animateMoveForPanX(e, animateOptions, beginOptions, completeOptions);
    this.animateMoveForPanY(e, animateOptions, beginOptions, completeOptions);
  },

  /**
   * Moves the element horizontally, using the information in the given hammer event object.
   *
   * @param e
   * @param elementRect
   * @return {undefined}
   */
  animateMoveForPanX: function(e, animateOptions, beginOptions, completeOptions) {
    var x;

    if (this.movement.scroll) {
      x = this.startPosition.scrollLeft - e.deltaX;
    } else {
      x = this.startPosition.left + e.deltaX;

      // Limit movement if the user is dragging the element towards the inside of the container bounds
      if (this.bounds &amp;&amp; this.snapping.distanceThreshold) {
        if ((this.currentPosition.left - this.bounds.left) > this.snapping.distanceThreshold) {
          x = (this.startPosition.left + this.snapping.distanceThreshold) +
            ((e.deltaX - this.snapping.distanceThreshold) * this.snapping.distanceScale);
        } else if ((this.bounds.right - this.currentPosition.right) > this.snapping.distanceThreshold) {
          x = (this.startPosition.left - this.snapping.distanceThreshold) +
            ((e.deltaX + this.snapping.distanceThreshold) * this.snapping.distanceScale);
        }
      }
    }

    animateOptions.duration = 0;
    completeOptions.snapToContainerBounds = false;
    completeOptions.clearPositionData = false;

    this.animateMoveX(x, animateOptions, beginOptions, completeOptions);
  },

  /**
   * Moves the element vertically, using the information in the given hammer event object.
   *
   * @param e
   * @param elementRect
   * @return {undefined}
   */
  animateMoveForPanY: function(e, animateOptions, beginOptions, completeOptions) {
    var y;

    if (this.movement.scroll) {
      y = this.startPosition.scrollTop - e.deltaY;
    } else {
      y = this.startPosition.top + e.deltaY;

      // Limit movement if the user is dragging the element towards the inside of the container bounds
      if (this.bounds &amp;&amp; this.snapping.distanceThreshold) {
        if ((this.currentPosition.top - this.bounds.top) > this.snapping.distanceThreshold) {
          y = (this.startPosition.top + this.snapping.distanceThreshold) +
            ((e.deltaY - this.snapping.distanceThreshold) * this.snapping.distanceScale);
        } else if ((this.bounds.bottom - this.currentPosition.bottom) > this.snapping.distanceThreshold) {
          y = (this.startPosition.top - this.snapping.distanceThreshold) +
            ((e.deltaY + this.snapping.distanceThreshold) * this.snapping.distanceScale);
        }
      }
    }

    animateOptions.duration = 0;
    completeOptions.snapToContainerBounds = false;
    completeOptions.clearPositionData = false;

    this.animateMoveY(y, animateOptions, beginOptions, completeOptions);
  },

  /**
   * Starts a horizontal and/or vertical movement animation using the
   * information in the given Hammer event object.
   *
   * @param e
   * @return {undefined}
   */
  animateMoveForSwipe: function(e, animateOptions, beginOptions, completeOptions) {
    completeOptions.waitForXAndY = true;
    this.animateMoveForSwipeX(e, animateOptions, beginOptions, completeOptions);
    this.animateMoveForSwipeY(e, animateOptions, beginOptions, completeOptions);
  },

  animateMoveForSwipeX: function(e, animateOptions, beginOptions, completeOptions) {
    var distance = this.getInertiaDistance(e.velocityX);
    var duration = this.getInertiaDuration(e.velocityX);
    var x;

    if (this.movement.scroll) {
      x = this.currentPosition.scrollLeft + distance;
    } else {
      x = "-=" + distance;
    }

    _.extend(animateOptions, this.inertia.animateOptions, { duration: duration });
    completeOptions.snapToContainerBounds = true;
    completeOptions.clearPositionData = true;

    this.animateMoveX(x, animateOptions, beginOptions, completeOptions);
  },

  animateMoveForSwipeY: function(e, animateOptions, beginOptions, completeOptions) {
    var distance = this.getInertiaDistance(e.velocityY);
    var duration = this.getInertiaDuration(e.velocityY);
    var y;

    if (this.movement.scroll) {
      y = this.currentPosition.scrollTop + distance;
    } else {
      y = "-=" + distance;
    }

    _.extend(animateOptions, this.inertia.animateOptions, { duration: duration });
    completeOptions.snapToContainerBounds = true;
    completeOptions.clearPositionData = true;

    this.animateMoveY(y, animateOptions, beginOptions, completeOptions);
  },

  getInertiaDistance: function(velocity) {
    return this.inertia.distanceScale * velocity;
  },

  getInertiaDuration: function(velocity) {
    return Math.abs(this.inertia.durationScale * velocity);
  },

  snapToContainerBounds: function() {
    var self = this;

    // If we don't have container bounds, we can't snap to anything.
    // If we are moving by scrolling, we can't snap, because the browser doesn't let you pull the element inside the bounds.
    if (!self.bounds || self.movement.scroll) {
      return;
    }

    var x;
    if (this.currentPosition.left > self.bounds.left) {
      x = 0;
    } else if (this.currentPosition.right &lt; self.bounds.right) {
      x = "+=" + (self.bounds.right - this.currentPosition.right);
    }

    var y;
    if (this.currentPosition.top > self.bounds.top) {
      y = 0;
    } else if (this.currentPosition.bottom &lt; self.bounds.bottom) {
      y = "+=" + (self.bounds.bottom - this.currentPosition.bottom);
    }

    var animateOptions = _.extend({}, this.snapping.animateOptions);
    var beginOptions = {};
    var completeOptions = { snapToContainerBounds: false, clearPositionData: true };

    if (!_.isUndefined(x) &amp;&amp; !_.isUndefined(y)) {
      completeOptions.waitForXAndY = true;
      this.animateMoveX(x, animateOptions, beginOptions, completeOptions);
      this.animateMoveY(y, animateOptions, beginOptions, completeOptions);
    } else if (!_.isUndefined(x)) {
      this.animateMoveX(x, animateOptions, beginOptions, completeOptions);
    } else if (!_.isUndefined(y)) {
      this.animateMoveY(y, animateOptions, beginOptions, completeOptions);
    }
  },

  animateMoveX: function(x, animateOptions, beginOptions, completeOptions) {
    this.animateMoveXOrY(x, "x", animateOptions, beginOptions, completeOptions);
  },

  animateMoveY: function(y, animateOptions, beginOptions, completeOptions) {
    this.animateMoveXOrY(y, "y", animateOptions, beginOptions, completeOptions);
  },

  animateMoveXAndY: function(x, y, animateOptions, beginOptions, completeOptions) {
    completeOptions.waitForXAndY = true;
    this.animateMoveX(x, animateOptions, beginOptions, completeOptions);
    this.animateMoveY(y, animateOptions, beginOptions, completeOptions);
  },

  animateMoveXOrY: function(value, axis, animateOptions, beginOptions, completeOptions) {
    var self = this;
    var transform;

    /*
    animateOptions = animateOptions || {};
    beginOptions = beginOptions || {};
    completeOptions = completeOptions || {};
    */

    if (self.movement.scroll) {
      transform = "scroll";
      animateOptions.offset = value;
      animateOptions.axis = axis;
      animateOptions.container = self.movement.scrollContainerElement;
    } else {
      transform = {};
      if (axis === "x") {
        transform.left = value;
      } else {
        transform.top = value;
      }
    }

    completeOptions.count = 0;

    animateOptions = _.extend({
      complete: function() {
        // Wait for two invocations of the callback, which signals that both X and Y animations are complete
        if (completeOptions.waitForXAndY) {
          completeOptions.count++;
          if (completeOptions.count &lt; 2) {
            return;
          }
        }
        self.onAnimationComplete(completeOptions);
      }
    }, this.movement.animateOptions, animateOptions);

    this.isAnimating = true;

    if (!beginOptions.silent) {
      this.emit(DecksEvent("gesture:element:moving", this, this.element));
    }

    self.animator.animate(self.element, transform, animateOptions);
  },

  onAnimationComplete: function(options) {
    this.isAnimating = false;

    if (options.snapToContainerBounds) {
      this.snapToContainerBounds();
    }

    if (options.clearPositionData) {
      this.clearPositionData();
    }

    if (!options.silent) {
      this.emit(DecksEvent("gesture:element:moved", this, this.element));
    }
  },

  onGesturePanStart: function(e) {
    if (e.sender.element !== this.element) {
      return;
    }
    //console.log("pan start");
    this.updatePositionData(e.data);
  },

  onGesturePanAny: function(e) {
    if (e.sender.element !== this.element) {
      return;
    }
    //console.log("pan any");
    this.updatePositionData(e.data);
    var animateOptions = {};
    var beginOptions = {};
    var completeOptions = { waitForXAndY: true };
    this.animateMoveForPan(e.data, animateOptions, beginOptions, completeOptions);
  },

  onGesturePanX: function(e) {
    if (e.sender.element !== this.element) {
      return;
    }
    //console.log("pan x");
    this.updatePositionData(e.data);
    var animateOptions = {};
    var beginOptions = {};
    var completeOptions = { waitForXAndY: false };
    this.animateMoveForPanX(e.data, animateOptions, beginOptions, completeOptions);
  },

  onGesturePanY: function(e) {
    if (e.sender.element !== this.element) {
      return;
    }
    //console.log("pan y");
    this.updatePositionData(e.data);
    var animateOptions = {};
    var beginOptions = {};
    var completeOptions = { waitForXAndY: false };
    this.animateMoveForPanY(e.data, animateOptions, beginOptions, completeOptions);
  },

  onGesturePanEnd: function(e) {
    if (e.sender.element !== this.element) {
      return;
    }
    //console.log("pan end");
    // If the user swiped, the element will still be moving when the pan ends, so don't snap to bounds
    if (!this.isAnimating) {
      this.snapToContainerBounds();
    }
    this.clearPositionData();
  },

  onGesturePanCancel: function(e) {
    if (e.sender.element !== this.element) {
      return;
    }
    //console.log("pan cancel");
    // TODO: not sure what triggers this, or what is appropriate to do to handle it.
    if (this.isAnimating) {
      this.stopAnimation();
    }
  },

  onGestureSwipeAny: function(e) {
    if (e.sender.element !== this.element) {
      return;
    }
    //console.log("swipe any");
    var animateOptions = {};
    var beginOptions = {};
    var completeOptions = { waitForXAndY: true };
    this.animateMoveForSwipe(e.data, animateOptions, beginOptions, completeOptions);
  },

  onGestureSwipeX: function(e) {
    if (e.sender.element !== this.element) {
      return;
    }
    //console.log("swipe x");
    var animateOptions = {};
    var beginOptions = {};
    var completeOptions = { waitForXAndY: false };
    this.animateMoveForSwipeX(e.data, animateOptions, beginOptions, completeOptions);
  },

  onGestureSwipeY: function(e) {
    if (e.sender.element !== this.element) {
      return;
    }
    //console.log("swipe y");
    var animateOptions = {};
    var beginOptions = {};
    var completeOptions = { waitForXAndY: false };
    this.animateMoveForSwipeY(e.data, animateOptions, beginOptions, completeOptions);
  },

  onGestureTap: function(e) {
    if (e.sender.element !== this.element) {
      return;
    }
    if (this.isAnimating) {
      this.stopAnimation();
    }
  },

  onGesturePress: function(e) {
    if (e.sender.element !== this.element) {
      return;
    }
    if (this.isAnimating) {
      this.stopAnimation();
    }
  }
});

module.exports = GestureHandler;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Modules</h3><ul><li><a href="module-decks.html">decks</a></li><li><a href="events.html">decks/events</a></li><li><a href="layouts.html">decks/layouts</a></li><li><a href="ui.html">decks/ui</a></li><li><a href="dom.html">decks/ui/dom</a></li><li><a href="utils.html">decks/utils</a></li><li><a href="rect.html">decks/utils/rect</a></li></ul><h3>Classes</h3><ul><li><a href="BasicGridLayout.html">BasicGridLayout</a></li><li><a href="BasicStackLayout.html">BasicStackLayout</a></li><li><a href="Canvas.html">Canvas</a></li><li><a href="Deck.html">Deck</a></li><li><a href="DecksEvent.html">DecksEvent</a></li><li><a href="Emitter.html">Emitter</a></li><li><a href="Frame.html">Frame</a></li><li><a href="GestureEmitter.html">GestureEmitter</a></li><li><a href="GestureHandler.html">GestureHandler</a></li><li><a href="Item.html">Item</a></li><li><a href="ItemCollection.html">ItemCollection</a></li><li><a href="Layout.html">Layout</a></li><li><a href="MouseEnterLeaveEmitter.html">MouseEnterLeaveEmitter</a></li><li><a href="MouseOverOutEmitter.html">MouseOverOutEmitter</a></li><li><a href="MouseWheelEmitter.html">MouseWheelEmitter</a></li><li><a href="PanEmitter.html">PanEmitter</a></li><li><a href="PressEmitter.html">PressEmitter</a></li><li><a href="SwipeEmitter.html">SwipeEmitter</a></li><li><a href="TapEmitter.html">TapEmitter</a></li><li><a href="Viewport.html">Viewport</a></li><li><a href="ZoomLayout.html">ZoomLayout</a></li></ul><h3>Events</h3><ul><li><a href="PanEmitter.html#event:gesture:pan:any">gesture:pan:any</a></li><li><a href="PanEmitter.html#event:gesture:pan:cancel">gesture:pan:cancel</a></li><li><a href="PanEmitter.html#event:gesture:pan:end">gesture:pan:end</a></li><li><a href="PanEmitter.html#event:gesture:pan:start">gesture:pan:start</a></li><li><a href="PanEmitter.html#event:gesture:pan:x">gesture:pan:x</a></li><li><a href="PanEmitter.html#event:gesture:pan:y">gesture:pan:y</a></li><li><a href="PressEmitter.html#event:gesture:press">gesture:press</a></li><li><a href="SwipeEmitter.html#event:gesture:swipe:any">gesture:swipe:any</a></li><li><a href="SwipeEmitter.html#event:gesture:swipe:x">gesture:swipe:x</a></li><li><a href="SwipeEmitter.html#event:gesture:swipe:y">gesture:swipe:y</a></li><li><a href="TapEmitter.html#event:gesture:tap">gesture:tap</a></li></ul><h3>Mixins</h3><ul><li><a href="binder.html">binder</a></li><li><a href="hasEmitter.html">hasEmitter</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha5</a> on Thu Nov 20 2014 09:00:14 GMT-0700 (MST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>

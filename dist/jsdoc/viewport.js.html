<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: viewport.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: viewport.js</h1>

    


    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>var _ = require("lodash");
var binder = require("./events").binder;
var hasEmitter = require("./events").hasEmitter;
var DecksEvent = require("./events").DecksEvent;
var dom = require("./ui").dom;
var Item = require("./item");
var ItemCollection = require("./itemcollection");
var Layout = require("./layout");
var Frame = require("./frame");
var Canvas = require("./canvas");

/**
 * Viewport - manages visual (DOM) components
 *
 * @class
 * @mixes binder
 * @mixes hasEmitter
 * @param {!Object} options - options for viewport initialization
 * @param {!Object} options.animator - Animator object
 * @param {!Object} options.config - Configuration object
 * @param {!(Emitter|Object)} options.emitter - Emitter instance or options object
 * @param {!ItemCollection} options.itemCollection - ItemCollection instance
 * @param {!Layout} options.layout - Layout instance
 * @param {!Frame} options.frame - Frame instance
 * @param {!Canvas} options.canvas - Canvas instance
 * @param {?number} [options.throttleLoadOrUnloadRenderWait=1000] - Wait time for throttled loadOrUnloadRender
 * @param {?number} [options.throttleLoadOrUnloadRendersWait=1000] - Wait time for throttled loadOrUnloadRenders
 * @param {?number} [options.debounceDrawItemsWait=1000] - Wait time for debounced drawItems
 */
function Viewport(options) {
  if (!(this instanceof Viewport)) {
    return new Viewport(options);
  }

  options = _.merge({}, this.defaultOptions, options);

  // Create throttled/debounced versions of certain methods that are called frequently
  this.throttledLoadOrUnloadRenders = _.throttle(_.bind(this.loadOrUnloadRenders, this), options.throttleLoadOrUnloadRendersWait);
  this.throttledLoadOrUnloadRender = _.throttle(_.bind(this.loadOrUnloadRender, this), options.throttleLoadOrUnloadRenderWait);
  this.debouncedDrawItems = _.debounce(_.bind(this.drawItems, this), options.debounceDrawItemsWait);

  this.firstRender = true;

  /**
   * Data structure for storing the items and corresponding renders
   */
  this.renders = {};

  /**
   * Keeps track of how many renders are currently being drawn
   */
  this.rendersDrawingCount = 0;

  /**
   * Flag that indicates if the deck is ready.  Drawing actions are suppressed
   * until the deck is signaled as ready
   */
  this.isDeckReady = false;

  this.setAnimator(options.animator);
  this.setConfig(options.config);
  this.setEmitter(options.emitter, this.emitterEvents);
  this.setItemCollection(options.itemCollection);
  this.setLayout(options.layout);
  this.setFrame(options.frame);
  this.setCanvas(options.canvas);
}

_.extend(Viewport.prototype, binder, hasEmitter, /** @lends Viewport.prototype */ {
  /**
   * Default options for instances of Viewport
   */
  defaultOptions: {
    throttleLoadOrUnloadRenderWait: 1000,
    throttleLoadOrUnloadRendersWait: 1000,
    debounceDrawItemsWait: 1000
  },

  /**
   * Event to method mapping for binding to the decks emitter.
   */
  emitterEvents: {
    "deck:ready": "onDeckReady",
    "deck:layout:set": "onDeckLayoutSet",
    "deck:draw": "onDeckDraw",
    "frame:bounds:set": "onFrameBoundsSet",
    "item:changed": "onItemChanged",
    "item:index:changed": "onItemIndexChanged",
    "item:collection:item:removed": "onItemCollectionItemRemoved",
    "gesture:element:moved": "onGestureElementMoved"
  },

  setAnimator: function(animator) {
    if (!animator) {
      throw new Error("Viewport#setAnimator: animator is required");
    }

    if (this.animator) {
      throw new Error("Viewport#setAnimator: animator already set");
    }

    this.animator = animator;
  },

  setConfig: function(config) {
    if (!config) {
      throw new Error("Viewport#setConfig: config is required");
    }

    if (this.config) {
      throw new Error("Viewport#setConfig: config already set");
    }

    this.config = config;
  },

  setItemCollection: function(itemCollection) {
    if (!(itemCollection instanceof ItemCollection)) {
      throw new Error("Viewport#setItemCollection: itemCollection is required and must be an ItemCollection");
    }

    if (this.itemCollection) {
      throw new Error("Viewport#setItemCollection: itemCollection already set");
    }

    this.itemCollection = itemCollection;
    // itemCollection events are forwarded by the main deck emitter, so we don't need to subscribe to this directly
  },

  setLayout: function(layout) {
    if (!(layout instanceof Layout)) {
      throw new Error("Viewport#setLayout: layout is required and must be a Layout");
    }

    this.layout = layout;
  },

  setFrame: function(frame) {
    if (!(frame instanceof Frame)) {
      throw new Error("Viewport#setFrame: frame is required and must be a Frame");
    }

    if (this.frame) {
      throw new Error("Viewport#setFrame: frame already set");
    }

    this.frame = frame;
  },

  setCanvas: function(canvas) {
    if (!(canvas instanceof Canvas)) {
      throw new Error("Viewport#setCanvas: canvas is required and must be a Canvas");
    }

    if (this.canvas) {
      throw new Error("Viewport#setCanvas: canvas already set");
    }

    this.canvas = canvas;
  },

  /**
   * Starts the drawing (animation) process for an Item.
   *
   * 1. Request one or more "render" objects from the Layout.  A "render" is basically
   * an object that specifies where to place an item in the canvas, along with animation
   * information to animate the positioning/transform/delay/druation/etc.  A Layout can provide
   * more than one render for an single Item, if the item needs to be displayed multiple times within
   * the canvas (e.g. if one item belongs in multiple visual collections on the screen).
   *
   * 2. Initiate the draw process for each render.
   *
   * @param {!Item} item item to draw
   * @return {undefined}
   */
  drawItem: function(item, options) {
    if (!(item instanceof Item)) {
      throw new Error("Viewport#drawItem: item is required and must be an Item");
    }

    if (!this.isDeckReady) {
      if (this.config.debugDrawing) {
        console.warn("Viewport#drawItem: not drawing - deck is not ready");
      }
      return;
    }

    //this.emit(DecksEvent("viewport:item:drawing", this, item));

    // Give the layout some contextual info/objects to help with creating renders
    var layoutRenders = this.layout.getRenders(item, this.getLayoutMethodOptions()) || [];

    if (!_.isArray(layoutRenders)) {
      layoutRenders = [layoutRenders];
    }

    var renders = {};

    _.each(layoutRenders, function(render, index) {
      // Assign ids to each render (based on the array index), and change it from an array to
      // an object with the render id as the key, and the render as the value.  Also, add some additional
      // data to the render, like the item.
      _.merge(render, options, {
        id: "" + index,
        index: index,
        item: item
      });

      renders[render.id] = render;
    });

    this.drawRenders(item, renders);
  },

  /**
   * Starts the drawing process for all Items in the ItemCollection.
   *
   * @return {undefined}
   */
  drawItems: function(options) {
    var items = this.itemCollection.getItems();

    this.emit(DecksEvent("viewport:items:drawing", this, items));

    _.each(items, function(item) {
      this.drawItem(item, options);
    }, this);
  },

  /**
   * Starts the erasing process for an Item.  All of the renders for the Item will
   * be "erased" (removed from the DOM), possibly with an removal animation.  Once
   * each render is "erased" the actual render object is removed from the renders data
   * structure.  Once all of the Item's renders are removed, the item itself will be
   * removed from the renders data structure.
   *
   * @param {Item} item item for which to remove renders
   * @return {undefined}
   */
  eraseItem: function(item) {
    if (!(item instanceof Item)) {
      throw new Error("Viewport#eraseItem: item is required and must be an Item");
    }

    // Item will be removed once all the renders are fully removed
    item.isRemoving = true;

    this.emit(DecksEvent("viewport:item:erasing", this, item));

    this.eraseRenders(item);
  },

  /**
   * Starts the erasing process for all the Items in the ItemCollection.
   *
   * @return {undefined}
   */
  eraseItems: function() {
    var items = this.itemCollection.getItems();

    this.emit(DecksEvent("viewport:items:erasing", this, items));

    _.each(items, function(item) {
      this.eraseItem(item);
    }, this);
  },

  /**
   * Removes an item from the internal items/renders data structure.  This is called
   * automatically after eraseItem, once all the renders have been erased and removed.
   * This should not be called directly.
   *
   * @param {!Item} item Item to remove
   * @return {undefined}
   */
  removeItem: function(item) {
    if (!(item instanceof Item)) {
      throw new Error("Viewport#removeItem: item is required and must be an Item");
    }

    this.emit(DecksEvent("viewport:item:removing", this, item));

    delete this.renders[item.id];

    this.emit(DecksEvent("viewport:item:removed", this, item));
  },

  /**
   * Gets the renders object for the given Item.
   *
   * This returns the renders currently stored in the Viewport instance,
   * it does not request new renders from the Layout.
   *
   * @param {?Item} item item for which to get renders, or if not specified, get all renders
   * @return {Object[]} array of renders for the given item
   */
  getRenders: function(item) {
    // If no item specified, return all current renders
    if (!item) {
      return _(this.renders) // object with item ids as keys
        .map(_.values) // array of objects with render ids as keys
        .map(_.values) // array of arrays of renders
        .flatten() // array of renders
        .value();
    }

    if (!this.renders[item.id]) {
      this.renders[item.id] = {};
    }

    return this.renders[item.id];
  },

  /**
   * Checks if an Item currently has any renders stored in the Viewport items/renders
   * data structure.
   *
   * @param {!Item} item Item for which to check for the existence of renders
   * @return {boolean} true if the Item has renders, otherwise false
   */
  hasRenders: function(item) {
    return !_.isEmpty(this.getRenders(item));
  },

  /**
   * Stores the given render object in the Viewports internal items/renders data structure.
   *
   * This is called automatically after a render has been drawn (after the animation completes).
   * This should not be called directly.
   *
   * @param {!Object} render render to store
   * @return {undefined}
   */
  setRender: function(render) {
    if (!render) {
      throw new Error("Viewport#setRender: render is required");
    }

    var renders = this.getRenders(render.item);

    this.emit(DecksEvent("viewport:render:setting", this, render));

    renders[render.id] = render;

    this.emit(DecksEvent("viewport:render:set", this, render));
  },

  /**
   * Starts the drawing process for a render.
   *
   * A render is an object which contains a DOM element - the render "container" element,
   * a "transform" - a hash of CSS properties and values to animate/set, and an "animateOptions"
   * which is a hash of animation properties, like duration, easing, etc.  A render is drawn
   * by executing the transform on the element, using a compatible animation function like
   * VelocityJS.  The drawing/animation process is asynchronous - this method starts the process,
   * and callbacks are used to track completion of the animation.
   *
   * @param {!Object} options animation options
   * @param {!Object} options.render render object
   * @param {!HTMLElement} options.render.element render element
   * @param {!Object} options.render.transform hash of CSS style properties to animate
   * @param {!Object} options.render.animateOptions animation options
   * @return {undefined}
   */
  drawRender: function(render) {
    if (!render) {
      throw new Error("Viewport#drawRender: render is required");
    }

    if (!render.element) {
      throw new Error("Viewport#drawRender: render.element is required");
    }

    if (!render.transform) {
      throw new Error("Viewport#drawRender: render.transform is required");
    }

    if (!render.animateOptions) {
      throw new Error("Viewport#drawRender: render.animateOptions is required");
    }

    var animateOptions = this.getRenderAnimateOptions(render);

    this.rendersDrawingCount++;

    if (this.config.debugDrawing) {
      console.log("Viewport#drawRender: renders drawing count: " + this.rendersDrawingCount);
    }

    this.emit(DecksEvent("viewport:render:drawing", this, render));

    this.animator.animate({
      elements: render.element,
      properties: render.transform,
      options: animateOptions
    });
  },

  /**
   * Draws the specified renders for the given Item.
   *
   * The Layout getRenders method does not specify an element in the render object, because the Layout
   * has no knowledge of elements - it merely provides the transform and animateOptions that it wants to
   * apply the the element(s) for an Item.  The Viewport keeps track of the Items and renders in a tree data
   * structure.  When new renders are retrieved from teh Layout, this method will merge the new renders
   * with any existing renders, add new elements where needed, and mark other elements for removal, and applies
   * the new render transforms for any existing elements.
   *
   * @param {!Item} item Item for which to draw renders
   * @param {!Object} renders keyed object of renders to draw for the item
   * @return {undefined}
   */
  drawRenders: function(item, renders) {
    if (!(item instanceof Item)) {
      throw new Error("Viewport#drawRenders: item is required and must be an Item");
    }

    if (!renders) {
      throw new Error("Viewport#drawRenders: renders is required");
    }

    var newRenderIds = _.keys(renders);

    var previousRenders = this.getRenders(item);
    var previousRenderIds = _.keys(previousRenders);

    // If the new renders have keys that already exist, merge the renders
    var renderIdsToMerge = _.intersection(previousRenderIds, newRenderIds);

    // If the new renders don't have keys that already exist, remove the existing renders
    var renderIdsToRemove = _.difference(previousRenderIds, renderIdsToMerge);

    // If the new renders have keys that don't already exist, add those new renders
    var renderIdsToAdd = _.difference(newRenderIds, renderIdsToMerge);

    if (this.config.debugDrawing) {
      console.log("Viewport#drawRenders: drawing renders for item", JSON.stringify({
        item: item.id,
        previousRenderIds: previousRenderIds,
        newRenderIds: newRenderIds,
        renderIdsToMerge: renderIdsToMerge,
        renderIdsToRemove: renderIdsToRemove,
        renderIdsToAdd: renderIdsToAdd
      }));
    }

    // Previous and new render exist - copy the new data onto the previous, and
    // check if we need to re-draw (if transform has changed)
    _.each(renderIdsToMerge, function(renderId) {
      var previousRender = previousRenders[renderId];
      var newRender = renders[renderId];

      // Merge the old and new renders together, with new values winning over old values
      // This is done to preserve the render element, and other state values that are not
      // provided by the Layout's new render.
      var mergedRender = _.merge({}, previousRender, newRender);

      // If the new render has the same transform as the current render, and doesn't need to be
      // reloaded, we don't need to do anything
      if (_.isEqual(previousRender.transform, mergedRender.transform) &amp;&amp; !mergedRender.loadNeeded) {
        if (this.config.debugDrawing) {
          console.warn("Viewport#drawRenders: not redrawing item render (no change to transform)", item, mergedRender);
        }
        return;
      }

      // Start the animation of the merged render
      this.drawRender(mergedRender);
    }, this);

    // New render with no corresponding previous render - create the container element, and animate it
    _.each(renderIdsToAdd, function(renderId) {
      var newRender = renders[renderId];

      // Create a new render container element
      newRender.element = this.createRenderElement(item, newRender);

      // Unload the render (so it has a default UI state)
      this.unloadRender(newRender);

      // Start the animation of the new render
      this.drawRender(newRender);
    }, this);

    // Previous render exists with no corresponding new render - remove the previous render
    _.each(renderIdsToRemove, function(renderId) {
      var previousRender = previousRenders[renderId];

      // This render is no longer needed, start the erase process for it
      // This can happen if a Layout provides multiple renders for an Item, but another Layout only provides one render
      // for the Item.  We just throw away the extras.
      this.eraseRender(previousRender);
    }, this);
  },

  /**
   * Starts the erasing process for a render.  The erasing or hiding of a render is animated, and the actual
   * removal of the render is done after the animation completes.
   *
   * @param {!Object} render render to remove
   * @param {?Object} options additional options
   * @return {undefined}
   */
  eraseRender: function(render) {
    if (!render) {
      throw new Error("Viewport#eraseRender: render is required");
    }

    render.isRemoving = true;

    this.layout.setHideAnimation(render);

    this.emit(DecksEvent("viewport:render:erasing", this, render));

    // Once the "hide" operation is completed, the render will be removed
    this.drawRender(render);
  },

  /**
   * Removes all the renders for an item
   *
   * @param {!Item} item item from which to remove all renders
   * @param {?Number} index index of item, if known
   * @param {?Object} options additional options
   * @return {undefined}
   */
  eraseRenders: function(item) {
    if (!(item instanceof Item)) {
      throw new Error("Viewport#eraseRenders: item is required and must be an Item");
    }

    var renders = this.getRenders(item);

    this.emit(DecksEvent("viewport:renders:erasing", this, renders));

    _.each(renders, function(render) {
      this.eraseRender(render);
    }, this);
  },

  /**
   * Removes the given render from the Viewport's internal items/renders data structure.
   *
   * This is called automatically after a render has been erased (after the erase animation).
   * This should not be called directly.
   *
   * @param {!Object} render render to remove
   * @return {undefined}
   */
  removeRender: function(render) {
    if (!render) {
      throw new Error("Viewport#removeRender: render is required");
    }

    var renders = this.getRenders(render.item);

    this.emit(DecksEvent("viewport:render:removing", this, render));

    delete renders[render.id];

    this.emit(DecksEvent("viewport:render:removed", this, render));
  },

  /**
   * Gets the default animation options, extended with the options.render.animateOptions
   *
   * @param {!Object} options object to pass to callback methods, like complete
   * @return {Object} hash of animation options
   */
  getRenderAnimateOptions: function(render) {
    if (!render) {
      throw new Error("Viewport#getRenderAnimateOptions: render is required");
    }

    // Create a default animate options object with bound callbacks
    // for the animation events (begin, complete).  The merge the animationOptions
    // from the render on top of that.
    var defaultAnimateOptions = {
      begin: _.bind(function(elements) {
        render.animationBeginData = {
          elements: elements
        };
        this.onAnimationBegin(render);
      }, this),

      complete: _.bind(function(elements) {
        render.animationCompleteData = {
          elements: elements
        };
        this.onAnimationComplete(render);
      }, this)
    };

    return _.extend(defaultAnimateOptions, render.animateOptions);
  },

  /**
   * Creates a container element for an individual render
   *
   * @return {HTMLElement} detached DOM element which will become the container for a render element.
   */
  createRenderElement: function(item, render) {
    if (!(item instanceof Item)) {
      throw new Error("Viewport#createRenderElement: item is required and must be an Item");
    }

    if (!render) {
      throw new Error("Viewport#createRenderElement: render is required");
    }

    var element = dom.create("div");

    dom.addClass(element, this.config.itemClassName);
    dom.setStyle(element, "position", "absolute");
    dom.setStyle(element, "top", 0);
    dom.setStyle(element, "left", 0);
    dom.setAttr(element, "data-item-id", item.id);
    dom.setAttr(element, "data-render-id", render.id);

    return element;
  },

  /**
   * Delegates to the Layout instance to load the render contents.
   *
   * @param {!Object} render - render to load
   * @return {undefined}
   */
  loadRender: function(render) {
    if (!render) {
      throw new Error("Viewport#loadRender: render is required");
    }

    this.emit(DecksEvent("viewport:render:loading", this, render));

    this.layout.loadRender(render, this.getLayoutMethodOptions());

    if (render.loadNeeded) {
      render.loadNeeded = false;
    }

    this.emit(DecksEvent("viewport:render:loaded", this, render));
  },

  /**
   * Delegates to the layout instance to unload the render contents.
   *
   * @param {!Object} render - render to unload
   * @return {undefined}
   */
  unloadRender: function(render) {
    if (!render) {
      throw new Error("Viewport#unloadRender: render is required");
    }

    this.emit(DecksEvent("viewport:render:unloading", this, render));

    this.layout.unloadRender(render, this.getLayoutMethodOptions());

    this.emit(DecksEvent("viewport:render:unloaded", this, render));
  },

  /**
   * Loads or unloads a render depending on factors like whether its visible in the
   * frame element, etc.
   *
   * @param {!Object} render render to load or unload
   * @return {undefined}
   */
  loadOrUnloadRender: function(render) {
    if (!render) {
      throw new Error("Viewport#loadOrUnloadRender: render is required");
    }

    if (this.frame.isElementVisible(render.element) || render.loadNeeded) {
      this.loadRender(render);
    } else {
      this.unloadRender(render);
    }
  },

  /**
   * Loads or unloads all the renders managed by the Viewport.
   *
   * @return {undefined}
   */
  loadOrUnloadRenders: function() {
    _.each(this.getRenders(), function(render) {
      this.loadOrUnloadRender(render);
    }, this);
  },

  /**
   * Gets options to pass to Layout methods.
   *
   * @return {undefined}
   */
  getLayoutMethodOptions: function() {
    return {
      animator: this.animator,
      config: this.config,
      emitter: this.emitter,
      itemCollection: this.itemCollection,
      layout: this.layout,
      frame: this.frame,
      canvas: this.canvas,
      viewport: this
    };
  },

  /**
   * Called when the deck is ready.  Starts the drawing cycle for the items.
   *
   * @return {undefined}
   */
  onDeckReady: function() {
    this.isDeckReady = true;

    if (this.config.debugDrawing) {
      console.info("Viewport#onDeckReady: draw items");
    }

    this.drawItems({ loadNeeded: true });
  },

  onDeckLayoutSet: function(e) {
    var layout = e.data;

    this.setLayout(layout);

    if (this.config.debugDrawing) {
      console.info("Viewport#onDeckLayoutSet: draw items");
    }

    this.drawItems({ loadNeeded: true });
  },

  onDeckDraw: function() {
    if (this.config.debugDrawing) {
      console.info("Viewport#onDeckDraw: draw items");
    }

    this.drawItems({ loadNeeded: true });
  },

  onFrameBoundsSet: function() {
    if (this.config.debugDrawing) {
      console.info("Viewport#onFrameBoundsSet: draw items");
    }

    this.drawItems();
  },

  onItemChanged: function(e) {
    var item = e.sender;

    if (this.config.debugDrawing) {
      console.info("Viewport#onItemChanged: draw item", item);
    }

    this.drawItem(item, { loadNeeded: true });
  },

  onItemIndexChanged: function(e) {
    var item = e.sender;
    var index = e.data;

    if (this.config.debugDrawing) {
      console.info("Viewport#onItemIndexChanged: draw item", item, index);
    }

    this.drawItem(item, { loadNeeded: true });
  },

  onItemCollectionItemRemoved: function(e) {
    var item = e.data;

    if (this.config.debugDrawing) {
      console.info("Viewport#onItemCollectionItemRemoved: erase item", item);
    }

    this.eraseItem(item);
  },

  onAnimationBegin: function(render) {
    // This tells the Canvas to add the element to it's container element
    this.emit(DecksEvent("viewport:render:animation:begin", this, render));
  },

  onAnimationComplete: function(render) {
    var self = this;
    if (render.isRemoving) {
      // If the render was marked for removal, remove it from the Viewport data structure now
      this.removeRender(render);

      // If the item was marked for removal, and the final render for the item has been removed,
      // remove the item now
      if (render.item.isRemoving &amp;&amp; !this.hasRenders(render.item)) {
        this.removeItem(render.item);
      }
    } else {
      // Store the render in the Viewport data structure
      this.setRender(render);
    }

    this.rendersDrawingCount--;

    if (this.config.debugDrawing) {
      console.log("Viewport#onAnimationComplete: renders drawing count: " + this.rendersDrawingCount);

      if (this.rendersDrawingCount &lt; 0) {
        // TODO: This shouldn't happen - if it happens, need to figure out why
        console.warn("Viewport#onAnimationComplete: rendersDrawingCount is less than 0 (this is a bug): " + this.rendersDrawingCount);
      }
    }

    if (this.rendersDrawingCount === 0) {
      var delay = 2500;
      // This signals the end of the current drawing cycle
      if(this.firstRender) {
        this.firstRender = false;
        delay = 0;
      }
      setTimeout(function() {
        self.loadOrUnloadRenders();
        self.emit(DecksEvent("viewport:all:renders:drawn", self));
      }, delay);
    }
  },

  onGestureElementMoved: function(e) {
    var element = e.data;
    if (element === this.canvas.element) {
      this.onCanvasElementMoved(e);
    }
  },

  onCanvasElementMoved: function() {
    this.throttledLoadOrUnloadRenders();
  }
});

module.exports = Viewport;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Modules</h3><ul><li><a href="module-decks.html">decks</a></li><li><a href="events.html">decks/events</a></li><li><a href="layouts.html">decks/layouts</a></li><li><a href="ui.html">decks/ui</a></li><li><a href="dom.html">decks/ui/dom</a></li><li><a href="utils.html">decks/utils</a></li><li><a href="rect.html">decks/utils/rect</a></li></ul><h3>Classes</h3><ul><li><a href="BasicGridLayout.html">BasicGridLayout</a></li><li><a href="BasicStackLayout.html">BasicStackLayout</a></li><li><a href="Canvas.html">Canvas</a></li><li><a href="Deck.html">Deck</a></li><li><a href="DecksEvent.html">DecksEvent</a></li><li><a href="Emitter.html">Emitter</a></li><li><a href="Frame.html">Frame</a></li><li><a href="GestureEmitter.html">GestureEmitter</a></li><li><a href="GestureHandler.html">GestureHandler</a></li><li><a href="Item.html">Item</a></li><li><a href="ItemCollection.html">ItemCollection</a></li><li><a href="Layout.html">Layout</a></li><li><a href="MouseWheelEmitter.html">MouseWheelEmitter</a></li><li><a href="PanEmitter.html">PanEmitter</a></li><li><a href="PressEmitter.html">PressEmitter</a></li><li><a href="SwipeEmitter.html">SwipeEmitter</a></li><li><a href="TapEmitter.html">TapEmitter</a></li><li><a href="Viewport.html">Viewport</a></li><li><a href="ZoomLayout.html">ZoomLayout</a></li></ul><h3>Events</h3><ul><li><a href="PanEmitter.html#event:gesture:pan:any">gesture:pan:any</a></li><li><a href="PanEmitter.html#event:gesture:pan:cancel">gesture:pan:cancel</a></li><li><a href="PanEmitter.html#event:gesture:pan:end">gesture:pan:end</a></li><li><a href="PanEmitter.html#event:gesture:pan:start">gesture:pan:start</a></li><li><a href="PanEmitter.html#event:gesture:pan:x">gesture:pan:x</a></li><li><a href="PanEmitter.html#event:gesture:pan:y">gesture:pan:y</a></li><li><a href="PressEmitter.html#event:gesture:press">gesture:press</a></li><li><a href="SwipeEmitter.html#event:gesture:swipe:any">gesture:swipe:any</a></li><li><a href="SwipeEmitter.html#event:gesture:swipe:x">gesture:swipe:x</a></li><li><a href="SwipeEmitter.html#event:gesture:swipe:y">gesture:swipe:y</a></li><li><a href="TapEmitter.html#event:gesture:tap">gesture:tap</a></li></ul><h3>Mixins</h3><ul><li><a href="binder.html">binder</a></li><li><a href="hasEmitter.html">hasEmitter</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha5</a> on Wed Nov 05 2014 08:31:35 GMT-0700 (MST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>

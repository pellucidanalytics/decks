<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: viewport.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: viewport.js</h1>

    


    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>var _ = require("lodash");
var binder = require("./events").binder;
var hasEmitter = require("./events").hasEmitter;
var DecksEvent = require("./events").DecksEvent;
var dom = require("./ui").dom;
var ItemCollection = require("./itemcollection");
var Layout = require("./layout");
var Frame = require("./frame");
var Canvas = require("./canvas");
var raf = require("raf");

/**
 * Viewport - manages visual (DOM) components
 *
 * @class
 * @mixes binder
 * @mixes hasEmitter
 * @param {!Object} options - options for viewport initialization
 * @param {!Object} options.animator - Animator object
 * @param {!Object} options.config - Configuration object
 * @param {!(Emitter|Object)} options.emitter - Emitter instance or options object
 * @param {!ItemCollection} options.itemCollection - ItemCollection instance
 * @param {!Layout} options.layout - Layout instance
 * @param {!Frame} options.frame - Frame instance
 * @param {!Canvas} options.canvas - Canvas instance
 */
function Viewport(options) {
  if (!(this instanceof Viewport)) {
    return new Viewport(options);
  }

  options = _.merge({}, this.defaultOptions, options);

  /** Debounced version of load or unload renders */
  this.debouncedLoadOrUnloadRenders = _.debounce(_.bind(this.loadOrUnloadRenders, this), options.debouncedLoadOrUnloadRendersWait);

  /** Debounced version of drawItems */
  this.debouncedDrawItems = _.debounce(_.bind(this.drawItems, this), options.debouncedDrawItemsWait);

  /** Indicates if this is the first render cycle */
  this.isFirstRenderCycle = true;

  /** Data structure for storing the items and corresponding renders */
  this.renders = {};

  /** Keeps track of how many renders are currently being drawn */
  this.rendersDrawingCount = 0;

  this.renderCycleCompleteEventDelay = options.renderCycleCompleteEventDelay;

  /**
   * Flag that indicates if the deck is ready.  Drawing actions are suppressed
   * until the deck is signaled as ready
   */
  this.isDeckReady = false;

  this.layoutMethodOptions = {};

  this.setAnimator(options.animator);
  this.setConfig(options.config);
  this.setEmitter(options.emitter, this.emitterEvents);
  this.setItemCollection(options.itemCollection);
  this.setLayout(options.layout);
  this.setFrame(options.frame);
  this.setCanvas(options.canvas);
}

_.extend(Viewport.prototype, binder, hasEmitter, /** @lends Viewport.prototype */ {
  /**
   * Default options for instances of Viewport
   */
  defaultOptions: {
    debouncedLoadOrUnloadRendersWait: 1000,
    debouncedDrawItemsWait: 1000,
    renderCycleCompleteEventDelay: 2500
  },

  /**
   * Event to method mapping for binding to the decks emitter.
   */
  emitterEvents: {
    "deck:ready": "onDeckReady",
    "deck:layout:set": "onDeckLayoutSet",
    "deck:draw": "onDeckDraw",
    "frame:bounds:set": "onFrameBoundsSet",
    "item:changed": "onItemChanged",
    "item:index:changed": "onItemIndexChanged",
    "item:collection:item:removed": "onItemCollectionItemRemoved",
    "gesture:element:moved": "onGestureElementMoved"
  },

  setAnimator: function(animator) {
    if (!animator) {
      throw new Error("Viewport#setAnimator: animator is required");
    }

    if (this.animator) {
      throw new Error("Viewport#setAnimator: animator already set");
    }

    this.animator = this.layoutMethodOptions.animator = animator;
  },

  setConfig: function(config) {
    if (!config) {
      throw new Error("Viewport#setConfig: config is required");
    }

    if (this.config) {
      throw new Error("Viewport#setConfig: config already set");
    }

    this.config = this.layoutMethodOptions.config = config;
  },

  setItemCollection: function(itemCollection) {
    if (!(itemCollection instanceof ItemCollection)) {
      throw new Error("Viewport#setItemCollection: itemCollection is required and must be an ItemCollection");
    }

    if (this.itemCollection) {
      throw new Error("Viewport#setItemCollection: itemCollection already set");
    }

    this.itemCollection = this.layoutMethodOptions.itemCollection = itemCollection;
    // itemCollection events are forwarded by the main deck emitter, so we don't need to subscribe to this directly
  },

  setLayout: function(layout) {
    if (!(layout instanceof Layout)) {
      throw new Error("Viewport#setLayout: layout is required and must be a Layout");
    }

    this.layout = this.layoutMethodOptions.layout = layout;
  },

  setFrame: function(frame) {
    if (!(frame instanceof Frame)) {
      throw new Error("Viewport#setFrame: frame is required and must be a Frame");
    }

    if (this.frame) {
      throw new Error("Viewport#setFrame: frame already set");
    }

    this.frame = this.layoutMethodOptions.frame = frame;
  },

  setCanvas: function(canvas) {
    if (!(canvas instanceof Canvas)) {
      throw new Error("Viewport#setCanvas: canvas is required and must be a Canvas");
    }

    if (this.canvas) {
      throw new Error("Viewport#setCanvas: canvas already set");
    }

    this.canvas = this.layoutMethodOptions.canvas = canvas;
  },

  /**
   * Starts the drawing (animation) process for an Item.
   *
   * 1. Request one or more "render" objects from the Layout.  A "render" is basically
   * an object that specifies where to place an item in the canvas, along with animation
   * information to animate the positioning/transform/delay/druation/etc.  A Layout can provide
   * more than one render for an single Item, if the item needs to be displayed multiple times within
   * the canvas (e.g. if one item belongs in multiple visual collections on the screen).
   *
   * 2. Initiate the draw process for each render.
   *
   * @param {!Item} item item to draw
   * @param {?Object} options - additional options for drawing
   * @param {boolean} options.isLoadNeeded - indicates if the item should be re-loaded after the animation completes.
   * @return {undefined}
   */
  drawItem: function(item, options) {
    if (!this.isDeckReady) {
      if (this.config.debugDrawing) {
        console.warn("Viewport#drawItem: not drawing - deck is not ready");
      }
      return;
    }

    // Give the layout some contextual info/objects to help with creating renders
    var layoutRenders = this.layout.getRenders(item, this.layoutMethodOptions) || [];

    if (!_.isArray(layoutRenders)) {
      layoutRenders = [layoutRenders];
    }

    var renders = {};

    _.each(layoutRenders, function(render, index) {
      // Assign ids to each render (based on the array index), and change it from an array to
      // an object with the render id as the key, and the render as the value.  Also, add some additional
      // data to the render, like the item.
      //
      render.id = "" + index;
      render.index = index;
      render.item = item;
      if (options) {
        render.isLoadNeeded = !!options.isLoadNeeded;
      }

      renders[render.id] = render;
    });

    this.drawRenders(item, renders);
  },

  /**
   * Starts the drawing process for all Items in the ItemCollection.
   *
   * @return {undefined}
   */
  drawItems: function(options) {
    var items = this.itemCollection.getItems();

    _.each(items, function(item) {
      this.drawItem(item, options);
    }, this);
  },

  /**
   * Starts the erasing process for an Item.  All of the renders for the Item will
   * be "erased" (removed from the DOM), possibly with an removal animation.  Once
   * each render is "erased" the actual render object is removed from the renders data
   * structure.  Once all of the Item's renders are removed, the item itself will be
   * removed from the renders data structure.
   *
   * @param {Item} item item for which to remove renders
   * @return {undefined}
   */
  eraseItem: function(item) {
    // Mark the item for removal once all the renders for the item are hidden and removed
    item.isRemoving = true;

    this.eraseRenders(item);
  },

  /**
   * Starts the erasing process for all the Items in the ItemCollection.
   *
   * @return {undefined}
   */
  eraseItems: function() {
    var items = this.itemCollection.getItems();

    _.each(items, function(item) {
      this.eraseItem(item);
    }, this);
  },

  /**
   * Removes an item from the internal items/renders data structure.  This is called
   * automatically after eraseItem, once all the renders have been erased and removed.
   * This should not be called directly.
   *
   * @param {!Item} item Item to remove
   * @return {undefined}
   */
  removeItem: function(item) {
    delete this.renders[item.id];
  },

  /**
   * Gets the renders object for the given Item.
   *
   * This returns the renders currently stored in the Viewport instance,
   * it does not request new renders from the Layout.
   *
   * @param {?Item} item item for which to get renders, or if not specified, get all renders
   * @return {Object[]} array of renders for the given item
   */
  getRenders: function(item) {
    // If no item specified, return all current renders
    if (!item) {
      return _(this.renders) // object with item ids as keys
        .map(_.values) // array of objects with render ids as keys
        .map(_.values) // array of arrays of renders
        .flatten() // array of renders
        .value();
    }

    if (!this.renders[item.id]) {
      this.renders[item.id] = {};
    }

    return this.renders[item.id];
  },

  /**
   * Checks if an Item currently has any renders stored in the Viewport items/renders
   * data structure.
   *
   * @param {!Item} item Item for which to check for the existence of renders
   * @return {boolean} true if the Item has renders, otherwise false
   */
  hasRenders: function(item) {
    return !_.isEmpty(this.getRenders(item));
  },

  /**
   * Stores the given render object in the Viewports internal items/renders data structure.
   *
   * This is called automatically after a render has been drawn (after the animation completes).
   * This should not be called directly.
   *
   * @param {!Object} render render to store
   * @return {undefined}
   */
  setRender: function(render) {
    var renders = this.getRenders(render.item);

    renders[render.id] = render;

    this.emit(DecksEvent("viewport:render:drawn", this, render));
  },

  /**
   * Starts the drawing process for a render.
   *
   * A render is an object which contains a DOM element - the render "container" element,
   * a "transform" - a hash of CSS properties and values to animate/set, and an "animateOptions"
   * which is a hash of animation properties, like duration, easing, etc.  A render is drawn
   * by executing the transform on the element, using a compatible animation function like
   * VelocityJS.  The drawing/animation process is asynchronous - this method starts the process,
   * and callbacks are used to track completion of the animation.
   *
   * @param {!Object} options animation options
   * @param {!Object} options.render render object
   * @param {!HTMLElement} options.render.element render element
   * @param {!Object} options.render.transform hash of CSS style properties to animate
   * @param {!Object} options.render.animateOptions animation options
   * @return {undefined}
   */
  drawRender: function(render) {
    var self = this;

    self.setDefaultRenderAnimateOptions(render);

    self.rendersDrawingCount++;

    if (self.config.debugDrawing) {
      console.log("Viewport#drawRender: renders drawing count: " + self.rendersDrawingCount);
    }

    var eventName = render.isRemoving ? "viewport:render:erasing" : "viewport:render:drawing";

    raf(function() {
      // This event is handled by the Canvas, to make sure the element is in the DOM
      // Do this in one frame, and then start the animation in the next frame
      self.emit(DecksEvent(eventName, self, render));

      raf(function() {
        // Start the animation now
        self.animator.animate({
          elements: render.element,
          properties: render.transform,
          options: render.animateOptions
        });
      });
    });
  },

  /**
   * Draws the specified renders for the given Item.
   *
   * The Layout getRenders method does not specify an element in the render object, because the Layout
   * has no knowledge of elements - it merely provides the transform and animateOptions that it wants to
   * apply the the element(s) for an Item.  The Viewport keeps track of the Items and renders in a tree data
   * structure.  When new renders are retrieved from teh Layout, this method will merge the new renders
   * with any existing renders, add new elements where needed, and mark other elements for removal, and applies
   * the new render transforms for any existing elements.
   *
   * @param {!Item} item Item for which to draw renders
   * @param {!Object} renders keyed object of renders to draw for the item
   * @return {undefined}
   */
  drawRenders: function(item, renders) {
    // Get the new render ids
    var newRenderIds = _.keys(renders);

    // Get the previous render ids
    var previousRenders = this.getRenders(item);
    var previousRenderIds = _.keys(previousRenders);

    // If the new renders have keys that already exist, merge the renders
    var renderIdsToMerge = _.intersection(previousRenderIds, newRenderIds);

    // If the new renders don't have keys that match existing renders, remove these existing renders
    var renderIdsToRemove = _.difference(previousRenderIds, renderIdsToMerge);

    // If the new renders have keys that don't already exist, add those new renders
    var renderIdsToAdd = _.difference(newRenderIds, renderIdsToMerge);

    if (this.config.debugDrawing) {
      console.log("Viewport#drawRenders: drawing renders for item", JSON.stringify({
        item: item.id,
        previousRenderIds: previousRenderIds,
        newRenderIds: newRenderIds,
        renderIdsToMerge: renderIdsToMerge,
        renderIdsToRemove: renderIdsToRemove,
        renderIdsToAdd: renderIdsToAdd
      }));
    }

    // Previous and new render exist - copy the new data onto the previous, and
    // check if we need to re-draw (if transform has changed)
    _.each(renderIdsToMerge, function(renderId) {
      var previousRender = previousRenders[renderId];
      var newRender = renders[renderId];

      // Merge the old and new renders together, with new values winning over old values
      // This is done to preserve the render element, and other state values that are not
      // provided by the Layout's new render.
      var mergedRender = _.merge({}, previousRender, newRender);

      // If the new render has the same transform as the current render, and doesn't need to be
      // reloaded, we don't need to do anything
      if (_.isEqual(previousRender.transform, mergedRender.transform) &amp;&amp; !mergedRender.isLoadNeeded) {
        if (this.config.debugDrawing) {
          console.warn("Viewport#drawRenders: not redrawing item render (no change to transform)", item, mergedRender);
        }
        return;
      }

      // Start the animation of the merged render
      this.drawRender(mergedRender);
    }, this);

    // New render with no corresponding previous render - create the container element, and animate it
    _.each(renderIdsToAdd, function(renderId) {
      var newRender = renders[renderId];

      // Create a new render container element
      newRender.element = this.createRenderElement(item, newRender);

      // Unload the render (so it has a default UI state)
      this.initializeRender(newRender);

      // Start the animation of the new render
      this.drawRender(newRender);
    }, this);

    // Previous render exists with no corresponding new render - remove the previous render
    _.each(renderIdsToRemove, function(renderId) {
      var previousRender = previousRenders[renderId];

      // This render is no longer needed, start the erase process for it
      // This can happen if a Layout provides multiple renders for an Item, but another Layout only provides one render
      // for the Item.  We just throw away the extras.
      this.eraseRender(previousRender);
    }, this);
  },

  /**
   * Starts the erasing process for a render.  The erasing or hiding of a render is animated, and the actual
   * removal of the render is done after the animation completes.
   *
   * @param {!Object} render render to remove
   * @param {?Object} options additional options
   * @return {undefined}
   */
  eraseRender: function(render) {
    // Flag this render to be removed when the hide animation is complete
    render.isRemoving = true;

    this.layout.setHideAnimation(render, this.layoutMethodOptions);

    // Once the "hide" operation is completed, the render will be removed
    this.drawRender(render);
  },

  /**
   * Removes all the renders for an item
   *
   * @param {!Item} item item from which to remove all renders
   * @param {?Number} index index of item, if known
   * @param {?Object} options additional options
   * @return {undefined}
   */
  eraseRenders: function(item) {
    var renders = this.getRenders(item);

    _.each(renders, function(render) {
      this.eraseRender(render);
    }, this);
  },

  /**
   * Removes the given render from the Viewport's internal items/renders data structure.
   *
   * This is called automatically after a render has been erased (after the erase animation).
   * This should not be called directly.
   *
   * @param {!Object} render render to remove
   * @return {undefined}
   */
  removeRender: function(render) {
    var renders = this.getRenders(render.item);

    delete renders[render.id];

    this.emit(DecksEvent("viewport:render:erased", this, render));
  },

  /**
   * Gets the default animation options, extended with the options.render.animateOptions
   *
   * @param {!Object} options object to pass to callback methods, like complete
   * @return {Object} hash of animation options
   */
  setDefaultRenderAnimateOptions: function(render) {
    var self = this;

    // Add the "complete" callback for velocity animation complete
    render.animateOptions.complete = function(elements) {
      render.animationCompleteData = {
        elements: elements
      };
      self.onAnimationComplete(render);
    };
  },

  /**
   * Creates a container element for an individual render
   *
   * @return {HTMLElement} detached DOM element which will become the container for a render element.
   */
  createRenderElement: function(item, render) {
    var element = dom.create("div");

    dom.addClass(element, this.config.itemClassName);
    dom.setStyle(element, "position", "absolute");
    dom.setStyle(element, "top", 0);
    dom.setStyle(element, "left", 0);
    dom.setAttr(element, "data-item-id", item.id);
    dom.setAttr(element, "data-render-id", render.id);

    return element;
  },

  initializeRender: function(render) {
    this.layout.initializeRender(render, this.layoutMethodOptions);
  },

  /**
   * Delegates to the Layout instance to load the render contents.
   *
   * @param {!Object} render - render to load
   * @return {undefined}
   */
  loadRender: function(render) {
    this.layout.loadRender(render, this.layoutMethodOptions);

    if (render.isLoadNeeded) {
      render.isLoadNeeded = false;
    }
  },

  /**
   * Delegates to the layout instance to unload the render contents.
   *
   * @param {!Object} render - render to unload
   * @return {undefined}
   */
  unloadRender: function(render) {
    this.layout.unloadRender(render, this.layoutMethodOptions);
  },

  /**
   * Loads or unloads a render depending on factors like whether its visible in the
   * frame element, etc.
   *
   * @param {!Object} render render to load or unload
   * @return {undefined}
   */
  loadOrUnloadRender: function(render) {
    // TODO: should we wrap this in raf (requestAnimationFrame)?
    if (render.isLoadNeeded || this.frame.isElementVisible(render.element)) {
      this.loadRender(render);
    } else {
      this.unloadRender(render);
    }
  },

  /**
   * Loads or unloads all the renders managed by the Viewport.
   *
   * @return {undefined}
   */
  loadOrUnloadRenders: function() {
    _.each(this.getRenders(), function(render) {
      this.loadOrUnloadRender(render);
    }, this);
  },

  /**
   * Called when the deck is ready.  Starts the drawing cycle for the items.
   *
   * @return {undefined}
   */
  onDeckReady: function() {
    this.isDeckReady = true;

    if (this.config.debugDrawing) {
      console.info("Viewport#onDeckReady: draw items");
    }

    this.drawItems({ isLoadNeeded: true });
  },

  onDeckLayoutSet: function(e) {
    var layout = e.data;

    this.setLayout(layout);

    if (this.config.debugDrawing) {
      console.info("Viewport#onDeckLayoutSet: draw items");
    }

    this.drawItems({ isLoadNeeded: true });
  },

  onDeckDraw: function() {
    if (this.config.debugDrawing) {
      console.info("Viewport#onDeckDraw: draw items");
    }

    this.drawItems({ isLoadNeeded: true });
  },

  onFrameBoundsSet: function() {
    if (this.config.debugDrawing) {
      console.info("Viewport#onFrameBoundsSet: draw items");
    }

    this.drawItems();
  },

  onItemChanged: function(e) {
    var item = e.sender;

    if (this.config.debugDrawing) {
      console.info("Viewport#onItemChanged: draw item", item);
    }

    this.drawItem(item, { isLoadNeeded: true });
  },

  onItemIndexChanged: function(e) {
    var item = e.sender;
    var index = e.data;

    if (this.config.debugDrawing) {
      console.info("Viewport#onItemIndexChanged: draw item", item, index);
    }

    this.drawItem(item, { isLoadNeeded: true }); // TODO: not sure if load needed on item index change
  },

  onItemCollectionItemRemoved: function(e) {
    var item = e.data;

    if (this.config.debugDrawing) {
      console.info("Viewport#onItemCollectionItemRemoved: erase item", item);
    }

    this.eraseItem(item);
  },

  onAnimationComplete: function(render) {
    var self = this;

    if (render.isRemoving) {
      self.removeRender(render);

      if (render.item.isRemoving &amp;&amp; !self.hasRenders(render.item)) {
        self.removeItem(render.item);
      }
    } else {
      self.setRender(render);
    }

    self.rendersDrawingCount--;

    if (self.rendersDrawingCount === 0) {
      raf(function() {
        self.loadOrUnloadRenders();
        self.emit(DecksEvent("viewport:all:renders:drawn", self));
      });
    }
  },

  onGestureElementMoved: function(e) {
    var element = e.data;
    if (element === this.canvas.element) {
      this.onCanvasElementMoved(e);
    }
  },

  onCanvasElementMoved: function() {
    this.debouncedLoadOrUnloadRenders();
  }
});

module.exports = Viewport;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Modules</h3><ul><li><a href="module-decks.html">decks</a></li><li><a href="events.html">decks/events</a></li><li><a href="layouts.html">decks/layouts</a></li><li><a href="ui.html">decks/ui</a></li><li><a href="dom.html">decks/ui/dom</a></li><li><a href="utils.html">decks/utils</a></li><li><a href="rect.html">decks/utils/rect</a></li></ul><h3>Classes</h3><ul><li><a href="BasicGridLayout.html">BasicGridLayout</a></li><li><a href="BasicStackLayout.html">BasicStackLayout</a></li><li><a href="Canvas.html">Canvas</a></li><li><a href="Deck.html">Deck</a></li><li><a href="DecksEvent.html">DecksEvent</a></li><li><a href="Emitter.html">Emitter</a></li><li><a href="Frame.html">Frame</a></li><li><a href="GestureEmitter.html">GestureEmitter</a></li><li><a href="GestureHandler.html">GestureHandler</a></li><li><a href="Item.html">Item</a></li><li><a href="ItemCollection.html">ItemCollection</a></li><li><a href="Layout.html">Layout</a></li><li><a href="MouseWheelEmitter.html">MouseWheelEmitter</a></li><li><a href="PanEmitter.html">PanEmitter</a></li><li><a href="PressEmitter.html">PressEmitter</a></li><li><a href="SwipeEmitter.html">SwipeEmitter</a></li><li><a href="TapEmitter.html">TapEmitter</a></li><li><a href="Viewport.html">Viewport</a></li><li><a href="ZoomLayout.html">ZoomLayout</a></li></ul><h3>Events</h3><ul><li><a href="PanEmitter.html#event:gesture:pan:any">gesture:pan:any</a></li><li><a href="PanEmitter.html#event:gesture:pan:cancel">gesture:pan:cancel</a></li><li><a href="PanEmitter.html#event:gesture:pan:end">gesture:pan:end</a></li><li><a href="PanEmitter.html#event:gesture:pan:start">gesture:pan:start</a></li><li><a href="PanEmitter.html#event:gesture:pan:x">gesture:pan:x</a></li><li><a href="PanEmitter.html#event:gesture:pan:y">gesture:pan:y</a></li><li><a href="PressEmitter.html#event:gesture:press">gesture:press</a></li><li><a href="SwipeEmitter.html#event:gesture:swipe:any">gesture:swipe:any</a></li><li><a href="SwipeEmitter.html#event:gesture:swipe:x">gesture:swipe:x</a></li><li><a href="SwipeEmitter.html#event:gesture:swipe:y">gesture:swipe:y</a></li><li><a href="TapEmitter.html#event:gesture:tap">gesture:tap</a></li></ul><h3>Mixins</h3><ul><li><a href="binder.html">binder</a></li><li><a href="hasEmitter.html">hasEmitter</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha5</a> on Fri Nov 07 2014 11:17:26 GMT-0700 (MST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
